// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tfoplibrary.proto

#ifndef PROTOBUF_tfoplibrary_2eproto__INCLUDED
#define PROTOBUF_tfoplibrary_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3002000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3002000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "tensorflow/core/framework/node_def.pb.h"
#include "tensorflow/core/framework/function.pb.h"
#include "tensorflow/core/framework/tensor.pb.h"
#include "tensorflow/core/protobuf/config.pb.h"
#include "tensorflow/core/lib/core/error_codes.pb.h"
// @@protoc_insertion_point(includes)
namespace executor {
class TFOpContextDef;
class TFOpContextDefDefaultTypeInternal;
extern TFOpContextDefDefaultTypeInternal _TFOpContextDef_default_instance_;
class TFOpContextUpdate;
class TFOpContextUpdateDefaultTypeInternal;
extern TFOpContextUpdateDefaultTypeInternal _TFOpContextUpdate_default_instance_;
class TFOpKernelDef;
class TFOpKernelDefDefaultTypeInternal;
extern TFOpKernelDefDefaultTypeInternal _TFOpKernelDef_default_instance_;
class TFPushRequest;
class TFPushRequestDefaultTypeInternal;
extern TFPushRequestDefaultTypeInternal _TFPushRequest_default_instance_;
class TFTensors;
class TFTensorsDefaultTypeInternal;
extern TFTensorsDefaultTypeInternal _TFTensors_default_instance_;
}  // namespace executor
namespace tensorflow {
class ConfigProto;
class ConfigProtoDefaultTypeInternal;
extern ConfigProtoDefaultTypeInternal _ConfigProto_default_instance_;
class FunctionDef;
class FunctionDefDefaultTypeInternal;
extern FunctionDefDefaultTypeInternal _FunctionDef_default_instance_;
class FunctionDefLibrary;
class FunctionDefLibraryDefaultTypeInternal;
extern FunctionDefLibraryDefaultTypeInternal _FunctionDefLibrary_default_instance_;
class GPUOptions;
class GPUOptionsDefaultTypeInternal;
extern GPUOptionsDefaultTypeInternal _GPUOptions_default_instance_;
class GradientDef;
class GradientDefDefaultTypeInternal;
extern GradientDefDefaultTypeInternal _GradientDef_default_instance_;
class GraphOptions;
class GraphOptionsDefaultTypeInternal;
extern GraphOptionsDefaultTypeInternal _GraphOptions_default_instance_;
class NodeDef;
class NodeDefDefaultTypeInternal;
extern NodeDefDefaultTypeInternal _NodeDef_default_instance_;
class OptimizerOptions;
class OptimizerOptionsDefaultTypeInternal;
extern OptimizerOptionsDefaultTypeInternal _OptimizerOptions_default_instance_;
class RPCOptions;
class RPCOptionsDefaultTypeInternal;
extern RPCOptionsDefaultTypeInternal _RPCOptions_default_instance_;
class RunMetadata;
class RunMetadataDefaultTypeInternal;
extern RunMetadataDefaultTypeInternal _RunMetadata_default_instance_;
class RunOptions;
class RunOptionsDefaultTypeInternal;
extern RunOptionsDefaultTypeInternal _RunOptions_default_instance_;
class TensorProto;
class TensorProtoDefaultTypeInternal;
extern TensorProtoDefaultTypeInternal _TensorProto_default_instance_;
class ThreadPoolOptionProto;
class ThreadPoolOptionProtoDefaultTypeInternal;
extern ThreadPoolOptionProtoDefaultTypeInternal _ThreadPoolOptionProto_default_instance_;
namespace error {
}  // namespace error
}  // namespace tensorflow

namespace executor {

namespace protobuf_tfoplibrary_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_tfoplibrary_2eproto

// ===================================================================

class TFOpKernelDef : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:executor.TFOpKernelDef) */ {
 public:
  TFOpKernelDef();
  virtual ~TFOpKernelDef();

  TFOpKernelDef(const TFOpKernelDef& from);

  inline TFOpKernelDef& operator=(const TFOpKernelDef& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TFOpKernelDef& default_instance();

  static inline const TFOpKernelDef* internal_default_instance() {
    return reinterpret_cast<const TFOpKernelDef*>(
               &_TFOpKernelDef_default_instance_);
  }

  void Swap(TFOpKernelDef* other);

  // implements Message ----------------------------------------------

  inline TFOpKernelDef* New() const PROTOBUF_FINAL { return New(NULL); }

  TFOpKernelDef* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TFOpKernelDef& from);
  void MergeFrom(const TFOpKernelDef& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TFOpKernelDef* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .tensorflow.NodeDef nodedef = 2;
  bool has_nodedef() const;
  void clear_nodedef();
  static const int kNodedefFieldNumber = 2;
  const ::tensorflow::NodeDef& nodedef() const;
  ::tensorflow::NodeDef* mutable_nodedef();
  ::tensorflow::NodeDef* release_nodedef();
  void set_allocated_nodedef(::tensorflow::NodeDef* nodedef);

  // .tensorflow.ConfigProto cfgProto = 3;
  bool has_cfgproto() const;
  void clear_cfgproto();
  static const int kCfgProtoFieldNumber = 3;
  const ::tensorflow::ConfigProto& cfgproto() const;
  ::tensorflow::ConfigProto* mutable_cfgproto();
  ::tensorflow::ConfigProto* release_cfgproto();
  void set_allocated_cfgproto(::tensorflow::ConfigProto* cfgproto);

  // .tensorflow.FunctionDefLibrary funcDef = 4;
  bool has_funcdef() const;
  void clear_funcdef();
  static const int kFuncDefFieldNumber = 4;
  const ::tensorflow::FunctionDefLibrary& funcdef() const;
  ::tensorflow::FunctionDefLibrary* mutable_funcdef();
  ::tensorflow::FunctionDefLibrary* release_funcdef();
  void set_allocated_funcdef(::tensorflow::FunctionDefLibrary* funcdef);

  // int32 graph_def_version = 1;
  void clear_graph_def_version();
  static const int kGraphDefVersionFieldNumber = 1;
  ::google::protobuf::int32 graph_def_version() const;
  void set_graph_def_version(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:executor.TFOpKernelDef)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::tensorflow::NodeDef* nodedef_;
  ::tensorflow::ConfigProto* cfgproto_;
  ::tensorflow::FunctionDefLibrary* funcdef_;
  ::google::protobuf::int32 graph_def_version_;
  mutable int _cached_size_;
  friend struct  protobuf_tfoplibrary_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TFOpContextDef : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:executor.TFOpContextDef) */ {
 public:
  TFOpContextDef();
  virtual ~TFOpContextDef();

  TFOpContextDef(const TFOpContextDef& from);

  inline TFOpContextDef& operator=(const TFOpContextDef& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TFOpContextDef& default_instance();

  static inline const TFOpContextDef* internal_default_instance() {
    return reinterpret_cast<const TFOpContextDef*>(
               &_TFOpContextDef_default_instance_);
  }

  void Swap(TFOpContextDef* other);

  // implements Message ----------------------------------------------

  inline TFOpContextDef* New() const PROTOBUF_FINAL { return New(NULL); }

  TFOpContextDef* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TFOpContextDef& from);
  void MergeFrom(const TFOpContextDef& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TFOpContextDef* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .tensorflow.TensorProto inputs = 5;
  int inputs_size() const;
  void clear_inputs();
  static const int kInputsFieldNumber = 5;
  const ::tensorflow::TensorProto& inputs(int index) const;
  ::tensorflow::TensorProto* mutable_inputs(int index);
  ::tensorflow::TensorProto* add_inputs();
  ::google::protobuf::RepeatedPtrField< ::tensorflow::TensorProto >*
      mutable_inputs();
  const ::google::protobuf::RepeatedPtrField< ::tensorflow::TensorProto >&
      inputs() const;

  // int64 step_id = 1;
  void clear_step_id();
  static const int kStepIdFieldNumber = 1;
  ::google::protobuf::int64 step_id() const;
  void set_step_id(::google::protobuf::int64 value);

  // uint64 frame_id = 2;
  void clear_frame_id();
  static const int kFrameIdFieldNumber = 2;
  ::google::protobuf::uint64 frame_id() const;
  void set_frame_id(::google::protobuf::uint64 value);

  // int64 iter_id = 3;
  void clear_iter_id();
  static const int kIterIdFieldNumber = 3;
  ::google::protobuf::int64 iter_id() const;
  void set_iter_id(::google::protobuf::int64 value);

  // bool is_input_dead = 4;
  void clear_is_input_dead();
  static const int kIsInputDeadFieldNumber = 4;
  bool is_input_dead() const;
  void set_is_input_dead(bool value);

  // @@protoc_insertion_point(class_scope:executor.TFOpContextDef)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::tensorflow::TensorProto > inputs_;
  ::google::protobuf::int64 step_id_;
  ::google::protobuf::uint64 frame_id_;
  ::google::protobuf::int64 iter_id_;
  bool is_input_dead_;
  mutable int _cached_size_;
  friend struct  protobuf_tfoplibrary_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TFOpContextUpdate : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:executor.TFOpContextUpdate) */ {
 public:
  TFOpContextUpdate();
  virtual ~TFOpContextUpdate();

  TFOpContextUpdate(const TFOpContextUpdate& from);

  inline TFOpContextUpdate& operator=(const TFOpContextUpdate& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TFOpContextUpdate& default_instance();

  static inline const TFOpContextUpdate* internal_default_instance() {
    return reinterpret_cast<const TFOpContextUpdate*>(
               &_TFOpContextUpdate_default_instance_);
  }

  void Swap(TFOpContextUpdate* other);

  // implements Message ----------------------------------------------

  inline TFOpContextUpdate* New() const PROTOBUF_FINAL { return New(NULL); }

  TFOpContextUpdate* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TFOpContextUpdate& from);
  void MergeFrom(const TFOpContextUpdate& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TFOpContextUpdate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .tensorflow.TensorProto outputs = 2;
  int outputs_size() const;
  void clear_outputs();
  static const int kOutputsFieldNumber = 2;
  const ::tensorflow::TensorProto& outputs(int index) const;
  ::tensorflow::TensorProto* mutable_outputs(int index);
  ::tensorflow::TensorProto* add_outputs();
  ::google::protobuf::RepeatedPtrField< ::tensorflow::TensorProto >*
      mutable_outputs();
  const ::google::protobuf::RepeatedPtrField< ::tensorflow::TensorProto >&
      outputs() const;

  // string status_msg = 5;
  void clear_status_msg();
  static const int kStatusMsgFieldNumber = 5;
  const ::std::string& status_msg() const;
  void set_status_msg(const ::std::string& value);
  #if LANG_CXX11
  void set_status_msg(::std::string&& value);
  #endif
  void set_status_msg(const char* value);
  void set_status_msg(const char* value, size_t size);
  ::std::string* mutable_status_msg();
  ::std::string* release_status_msg();
  void set_allocated_status_msg(::std::string* status_msg);

  // bool is_output_dead = 1;
  void clear_is_output_dead();
  static const int kIsOutputDeadFieldNumber = 1;
  bool is_output_dead() const;
  void set_is_output_dead(bool value);

  // .tensorflow.error.Code status_code = 4;
  void clear_status_code();
  static const int kStatusCodeFieldNumber = 4;
  ::tensorflow::error::Code status_code() const;
  void set_status_code(::tensorflow::error::Code value);

  // @@protoc_insertion_point(class_scope:executor.TFOpContextUpdate)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::tensorflow::TensorProto > outputs_;
  ::google::protobuf::internal::ArenaStringPtr status_msg_;
  bool is_output_dead_;
  int status_code_;
  mutable int _cached_size_;
  friend struct  protobuf_tfoplibrary_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TFTensors : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:executor.TFTensors) */ {
 public:
  TFTensors();
  virtual ~TFTensors();

  TFTensors(const TFTensors& from);

  inline TFTensors& operator=(const TFTensors& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TFTensors& default_instance();

  static inline const TFTensors* internal_default_instance() {
    return reinterpret_cast<const TFTensors*>(
               &_TFTensors_default_instance_);
  }

  void Swap(TFTensors* other);

  // implements Message ----------------------------------------------

  inline TFTensors* New() const PROTOBUF_FINAL { return New(NULL); }

  TFTensors* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TFTensors& from);
  void MergeFrom(const TFTensors& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TFTensors* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .tensorflow.TensorProto tensors = 1;
  int tensors_size() const;
  void clear_tensors();
  static const int kTensorsFieldNumber = 1;
  const ::tensorflow::TensorProto& tensors(int index) const;
  ::tensorflow::TensorProto* mutable_tensors(int index);
  ::tensorflow::TensorProto* add_tensors();
  ::google::protobuf::RepeatedPtrField< ::tensorflow::TensorProto >*
      mutable_tensors();
  const ::google::protobuf::RepeatedPtrField< ::tensorflow::TensorProto >&
      tensors() const;

  // @@protoc_insertion_point(class_scope:executor.TFTensors)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::tensorflow::TensorProto > tensors_;
  mutable int _cached_size_;
  friend struct  protobuf_tfoplibrary_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TFPushRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:executor.TFPushRequest) */ {
 public:
  TFPushRequest();
  virtual ~TFPushRequest();

  TFPushRequest(const TFPushRequest& from);

  inline TFPushRequest& operator=(const TFPushRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TFPushRequest& default_instance();

  static inline const TFPushRequest* internal_default_instance() {
    return reinterpret_cast<const TFPushRequest*>(
               &_TFPushRequest_default_instance_);
  }

  void Swap(TFPushRequest* other);

  // implements Message ----------------------------------------------

  inline TFPushRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  TFPushRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TFPushRequest& from);
  void MergeFrom(const TFPushRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TFPushRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .tensorflow.TensorProto data = 1;
  int data_size() const;
  void clear_data();
  static const int kDataFieldNumber = 1;
  const ::tensorflow::TensorProto& data(int index) const;
  ::tensorflow::TensorProto* mutable_data(int index);
  ::tensorflow::TensorProto* add_data();
  ::google::protobuf::RepeatedPtrField< ::tensorflow::TensorProto >*
      mutable_data();
  const ::google::protobuf::RepeatedPtrField< ::tensorflow::TensorProto >&
      data() const;

  // repeated .tensorflow.TensorProto tensors = 2;
  int tensors_size() const;
  void clear_tensors();
  static const int kTensorsFieldNumber = 2;
  const ::tensorflow::TensorProto& tensors(int index) const;
  ::tensorflow::TensorProto* mutable_tensors(int index);
  ::tensorflow::TensorProto* add_tensors();
  ::google::protobuf::RepeatedPtrField< ::tensorflow::TensorProto >*
      mutable_tensors();
  const ::google::protobuf::RepeatedPtrField< ::tensorflow::TensorProto >&
      tensors() const;

  // @@protoc_insertion_point(class_scope:executor.TFPushRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::tensorflow::TensorProto > data_;
  ::google::protobuf::RepeatedPtrField< ::tensorflow::TensorProto > tensors_;
  mutable int _cached_size_;
  friend struct  protobuf_tfoplibrary_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// TFOpKernelDef

// int32 graph_def_version = 1;
inline void TFOpKernelDef::clear_graph_def_version() {
  graph_def_version_ = 0;
}
inline ::google::protobuf::int32 TFOpKernelDef::graph_def_version() const {
  // @@protoc_insertion_point(field_get:executor.TFOpKernelDef.graph_def_version)
  return graph_def_version_;
}
inline void TFOpKernelDef::set_graph_def_version(::google::protobuf::int32 value) {
  
  graph_def_version_ = value;
  // @@protoc_insertion_point(field_set:executor.TFOpKernelDef.graph_def_version)
}

// .tensorflow.NodeDef nodedef = 2;
inline bool TFOpKernelDef::has_nodedef() const {
  return this != internal_default_instance() && nodedef_ != NULL;
}
inline void TFOpKernelDef::clear_nodedef() {
  if (GetArenaNoVirtual() == NULL && nodedef_ != NULL) delete nodedef_;
  nodedef_ = NULL;
}
inline const ::tensorflow::NodeDef& TFOpKernelDef::nodedef() const {
  // @@protoc_insertion_point(field_get:executor.TFOpKernelDef.nodedef)
  return nodedef_ != NULL ? *nodedef_
                         : *::tensorflow::NodeDef::internal_default_instance();
}
inline ::tensorflow::NodeDef* TFOpKernelDef::mutable_nodedef() {
  
  if (nodedef_ == NULL) {
    nodedef_ = new ::tensorflow::NodeDef;
  }
  // @@protoc_insertion_point(field_mutable:executor.TFOpKernelDef.nodedef)
  return nodedef_;
}
inline ::tensorflow::NodeDef* TFOpKernelDef::release_nodedef() {
  // @@protoc_insertion_point(field_release:executor.TFOpKernelDef.nodedef)
  
  ::tensorflow::NodeDef* temp = nodedef_;
  nodedef_ = NULL;
  return temp;
}
inline void TFOpKernelDef::set_allocated_nodedef(::tensorflow::NodeDef* nodedef) {
  delete nodedef_;
  if (nodedef != NULL && nodedef->GetArena() != NULL) {
    ::tensorflow::NodeDef* new_nodedef = new ::tensorflow::NodeDef;
    new_nodedef->CopyFrom(*nodedef);
    nodedef = new_nodedef;
  }
  nodedef_ = nodedef;
  if (nodedef) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:executor.TFOpKernelDef.nodedef)
}

// .tensorflow.ConfigProto cfgProto = 3;
inline bool TFOpKernelDef::has_cfgproto() const {
  return this != internal_default_instance() && cfgproto_ != NULL;
}
inline void TFOpKernelDef::clear_cfgproto() {
  if (GetArenaNoVirtual() == NULL && cfgproto_ != NULL) delete cfgproto_;
  cfgproto_ = NULL;
}
inline const ::tensorflow::ConfigProto& TFOpKernelDef::cfgproto() const {
  // @@protoc_insertion_point(field_get:executor.TFOpKernelDef.cfgProto)
  return cfgproto_ != NULL ? *cfgproto_
                         : *::tensorflow::ConfigProto::internal_default_instance();
}
inline ::tensorflow::ConfigProto* TFOpKernelDef::mutable_cfgproto() {
  
  if (cfgproto_ == NULL) {
    cfgproto_ = new ::tensorflow::ConfigProto;
  }
  // @@protoc_insertion_point(field_mutable:executor.TFOpKernelDef.cfgProto)
  return cfgproto_;
}
inline ::tensorflow::ConfigProto* TFOpKernelDef::release_cfgproto() {
  // @@protoc_insertion_point(field_release:executor.TFOpKernelDef.cfgProto)
  
  ::tensorflow::ConfigProto* temp = cfgproto_;
  cfgproto_ = NULL;
  return temp;
}
inline void TFOpKernelDef::set_allocated_cfgproto(::tensorflow::ConfigProto* cfgproto) {
  delete cfgproto_;
  if (cfgproto != NULL && cfgproto->GetArena() != NULL) {
    ::tensorflow::ConfigProto* new_cfgproto = new ::tensorflow::ConfigProto;
    new_cfgproto->CopyFrom(*cfgproto);
    cfgproto = new_cfgproto;
  }
  cfgproto_ = cfgproto;
  if (cfgproto) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:executor.TFOpKernelDef.cfgProto)
}

// .tensorflow.FunctionDefLibrary funcDef = 4;
inline bool TFOpKernelDef::has_funcdef() const {
  return this != internal_default_instance() && funcdef_ != NULL;
}
inline void TFOpKernelDef::clear_funcdef() {
  if (GetArenaNoVirtual() == NULL && funcdef_ != NULL) delete funcdef_;
  funcdef_ = NULL;
}
inline const ::tensorflow::FunctionDefLibrary& TFOpKernelDef::funcdef() const {
  // @@protoc_insertion_point(field_get:executor.TFOpKernelDef.funcDef)
  return funcdef_ != NULL ? *funcdef_
                         : *::tensorflow::FunctionDefLibrary::internal_default_instance();
}
inline ::tensorflow::FunctionDefLibrary* TFOpKernelDef::mutable_funcdef() {
  
  if (funcdef_ == NULL) {
    funcdef_ = new ::tensorflow::FunctionDefLibrary;
  }
  // @@protoc_insertion_point(field_mutable:executor.TFOpKernelDef.funcDef)
  return funcdef_;
}
inline ::tensorflow::FunctionDefLibrary* TFOpKernelDef::release_funcdef() {
  // @@protoc_insertion_point(field_release:executor.TFOpKernelDef.funcDef)
  
  ::tensorflow::FunctionDefLibrary* temp = funcdef_;
  funcdef_ = NULL;
  return temp;
}
inline void TFOpKernelDef::set_allocated_funcdef(::tensorflow::FunctionDefLibrary* funcdef) {
  delete funcdef_;
  if (funcdef != NULL && funcdef->GetArena() != NULL) {
    ::tensorflow::FunctionDefLibrary* new_funcdef = new ::tensorflow::FunctionDefLibrary;
    new_funcdef->CopyFrom(*funcdef);
    funcdef = new_funcdef;
  }
  funcdef_ = funcdef;
  if (funcdef) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:executor.TFOpKernelDef.funcDef)
}

// -------------------------------------------------------------------

// TFOpContextDef

// int64 step_id = 1;
inline void TFOpContextDef::clear_step_id() {
  step_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 TFOpContextDef::step_id() const {
  // @@protoc_insertion_point(field_get:executor.TFOpContextDef.step_id)
  return step_id_;
}
inline void TFOpContextDef::set_step_id(::google::protobuf::int64 value) {
  
  step_id_ = value;
  // @@protoc_insertion_point(field_set:executor.TFOpContextDef.step_id)
}

// uint64 frame_id = 2;
inline void TFOpContextDef::clear_frame_id() {
  frame_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 TFOpContextDef::frame_id() const {
  // @@protoc_insertion_point(field_get:executor.TFOpContextDef.frame_id)
  return frame_id_;
}
inline void TFOpContextDef::set_frame_id(::google::protobuf::uint64 value) {
  
  frame_id_ = value;
  // @@protoc_insertion_point(field_set:executor.TFOpContextDef.frame_id)
}

// int64 iter_id = 3;
inline void TFOpContextDef::clear_iter_id() {
  iter_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 TFOpContextDef::iter_id() const {
  // @@protoc_insertion_point(field_get:executor.TFOpContextDef.iter_id)
  return iter_id_;
}
inline void TFOpContextDef::set_iter_id(::google::protobuf::int64 value) {
  
  iter_id_ = value;
  // @@protoc_insertion_point(field_set:executor.TFOpContextDef.iter_id)
}

// bool is_input_dead = 4;
inline void TFOpContextDef::clear_is_input_dead() {
  is_input_dead_ = false;
}
inline bool TFOpContextDef::is_input_dead() const {
  // @@protoc_insertion_point(field_get:executor.TFOpContextDef.is_input_dead)
  return is_input_dead_;
}
inline void TFOpContextDef::set_is_input_dead(bool value) {
  
  is_input_dead_ = value;
  // @@protoc_insertion_point(field_set:executor.TFOpContextDef.is_input_dead)
}

// repeated .tensorflow.TensorProto inputs = 5;
inline int TFOpContextDef::inputs_size() const {
  return inputs_.size();
}
inline void TFOpContextDef::clear_inputs() {
  inputs_.Clear();
}
inline const ::tensorflow::TensorProto& TFOpContextDef::inputs(int index) const {
  // @@protoc_insertion_point(field_get:executor.TFOpContextDef.inputs)
  return inputs_.Get(index);
}
inline ::tensorflow::TensorProto* TFOpContextDef::mutable_inputs(int index) {
  // @@protoc_insertion_point(field_mutable:executor.TFOpContextDef.inputs)
  return inputs_.Mutable(index);
}
inline ::tensorflow::TensorProto* TFOpContextDef::add_inputs() {
  // @@protoc_insertion_point(field_add:executor.TFOpContextDef.inputs)
  return inputs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::tensorflow::TensorProto >*
TFOpContextDef::mutable_inputs() {
  // @@protoc_insertion_point(field_mutable_list:executor.TFOpContextDef.inputs)
  return &inputs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::tensorflow::TensorProto >&
TFOpContextDef::inputs() const {
  // @@protoc_insertion_point(field_list:executor.TFOpContextDef.inputs)
  return inputs_;
}

// -------------------------------------------------------------------

// TFOpContextUpdate

// bool is_output_dead = 1;
inline void TFOpContextUpdate::clear_is_output_dead() {
  is_output_dead_ = false;
}
inline bool TFOpContextUpdate::is_output_dead() const {
  // @@protoc_insertion_point(field_get:executor.TFOpContextUpdate.is_output_dead)
  return is_output_dead_;
}
inline void TFOpContextUpdate::set_is_output_dead(bool value) {
  
  is_output_dead_ = value;
  // @@protoc_insertion_point(field_set:executor.TFOpContextUpdate.is_output_dead)
}

// repeated .tensorflow.TensorProto outputs = 2;
inline int TFOpContextUpdate::outputs_size() const {
  return outputs_.size();
}
inline void TFOpContextUpdate::clear_outputs() {
  outputs_.Clear();
}
inline const ::tensorflow::TensorProto& TFOpContextUpdate::outputs(int index) const {
  // @@protoc_insertion_point(field_get:executor.TFOpContextUpdate.outputs)
  return outputs_.Get(index);
}
inline ::tensorflow::TensorProto* TFOpContextUpdate::mutable_outputs(int index) {
  // @@protoc_insertion_point(field_mutable:executor.TFOpContextUpdate.outputs)
  return outputs_.Mutable(index);
}
inline ::tensorflow::TensorProto* TFOpContextUpdate::add_outputs() {
  // @@protoc_insertion_point(field_add:executor.TFOpContextUpdate.outputs)
  return outputs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::tensorflow::TensorProto >*
TFOpContextUpdate::mutable_outputs() {
  // @@protoc_insertion_point(field_mutable_list:executor.TFOpContextUpdate.outputs)
  return &outputs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::tensorflow::TensorProto >&
TFOpContextUpdate::outputs() const {
  // @@protoc_insertion_point(field_list:executor.TFOpContextUpdate.outputs)
  return outputs_;
}

// .tensorflow.error.Code status_code = 4;
inline void TFOpContextUpdate::clear_status_code() {
  status_code_ = 0;
}
inline ::tensorflow::error::Code TFOpContextUpdate::status_code() const {
  // @@protoc_insertion_point(field_get:executor.TFOpContextUpdate.status_code)
  return static_cast< ::tensorflow::error::Code >(status_code_);
}
inline void TFOpContextUpdate::set_status_code(::tensorflow::error::Code value) {
  
  status_code_ = value;
  // @@protoc_insertion_point(field_set:executor.TFOpContextUpdate.status_code)
}

// string status_msg = 5;
inline void TFOpContextUpdate::clear_status_msg() {
  status_msg_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TFOpContextUpdate::status_msg() const {
  // @@protoc_insertion_point(field_get:executor.TFOpContextUpdate.status_msg)
  return status_msg_.GetNoArena();
}
inline void TFOpContextUpdate::set_status_msg(const ::std::string& value) {
  
  status_msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:executor.TFOpContextUpdate.status_msg)
}
#if LANG_CXX11
inline void TFOpContextUpdate::set_status_msg(::std::string&& value) {
  
  status_msg_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:executor.TFOpContextUpdate.status_msg)
}
#endif
inline void TFOpContextUpdate::set_status_msg(const char* value) {
  
  status_msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:executor.TFOpContextUpdate.status_msg)
}
inline void TFOpContextUpdate::set_status_msg(const char* value, size_t size) {
  
  status_msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:executor.TFOpContextUpdate.status_msg)
}
inline ::std::string* TFOpContextUpdate::mutable_status_msg() {
  
  // @@protoc_insertion_point(field_mutable:executor.TFOpContextUpdate.status_msg)
  return status_msg_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TFOpContextUpdate::release_status_msg() {
  // @@protoc_insertion_point(field_release:executor.TFOpContextUpdate.status_msg)
  
  return status_msg_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TFOpContextUpdate::set_allocated_status_msg(::std::string* status_msg) {
  if (status_msg != NULL) {
    
  } else {
    
  }
  status_msg_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), status_msg);
  // @@protoc_insertion_point(field_set_allocated:executor.TFOpContextUpdate.status_msg)
}

// -------------------------------------------------------------------

// TFTensors

// repeated .tensorflow.TensorProto tensors = 1;
inline int TFTensors::tensors_size() const {
  return tensors_.size();
}
inline void TFTensors::clear_tensors() {
  tensors_.Clear();
}
inline const ::tensorflow::TensorProto& TFTensors::tensors(int index) const {
  // @@protoc_insertion_point(field_get:executor.TFTensors.tensors)
  return tensors_.Get(index);
}
inline ::tensorflow::TensorProto* TFTensors::mutable_tensors(int index) {
  // @@protoc_insertion_point(field_mutable:executor.TFTensors.tensors)
  return tensors_.Mutable(index);
}
inline ::tensorflow::TensorProto* TFTensors::add_tensors() {
  // @@protoc_insertion_point(field_add:executor.TFTensors.tensors)
  return tensors_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::tensorflow::TensorProto >*
TFTensors::mutable_tensors() {
  // @@protoc_insertion_point(field_mutable_list:executor.TFTensors.tensors)
  return &tensors_;
}
inline const ::google::protobuf::RepeatedPtrField< ::tensorflow::TensorProto >&
TFTensors::tensors() const {
  // @@protoc_insertion_point(field_list:executor.TFTensors.tensors)
  return tensors_;
}

// -------------------------------------------------------------------

// TFPushRequest

// repeated .tensorflow.TensorProto data = 1;
inline int TFPushRequest::data_size() const {
  return data_.size();
}
inline void TFPushRequest::clear_data() {
  data_.Clear();
}
inline const ::tensorflow::TensorProto& TFPushRequest::data(int index) const {
  // @@protoc_insertion_point(field_get:executor.TFPushRequest.data)
  return data_.Get(index);
}
inline ::tensorflow::TensorProto* TFPushRequest::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:executor.TFPushRequest.data)
  return data_.Mutable(index);
}
inline ::tensorflow::TensorProto* TFPushRequest::add_data() {
  // @@protoc_insertion_point(field_add:executor.TFPushRequest.data)
  return data_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::tensorflow::TensorProto >*
TFPushRequest::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:executor.TFPushRequest.data)
  return &data_;
}
inline const ::google::protobuf::RepeatedPtrField< ::tensorflow::TensorProto >&
TFPushRequest::data() const {
  // @@protoc_insertion_point(field_list:executor.TFPushRequest.data)
  return data_;
}

// repeated .tensorflow.TensorProto tensors = 2;
inline int TFPushRequest::tensors_size() const {
  return tensors_.size();
}
inline void TFPushRequest::clear_tensors() {
  tensors_.Clear();
}
inline const ::tensorflow::TensorProto& TFPushRequest::tensors(int index) const {
  // @@protoc_insertion_point(field_get:executor.TFPushRequest.tensors)
  return tensors_.Get(index);
}
inline ::tensorflow::TensorProto* TFPushRequest::mutable_tensors(int index) {
  // @@protoc_insertion_point(field_mutable:executor.TFPushRequest.tensors)
  return tensors_.Mutable(index);
}
inline ::tensorflow::TensorProto* TFPushRequest::add_tensors() {
  // @@protoc_insertion_point(field_add:executor.TFPushRequest.tensors)
  return tensors_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::tensorflow::TensorProto >*
TFPushRequest::mutable_tensors() {
  // @@protoc_insertion_point(field_mutable_list:executor.TFPushRequest.tensors)
  return &tensors_;
}
inline const ::google::protobuf::RepeatedPtrField< ::tensorflow::TensorProto >&
TFPushRequest::tensors() const {
  // @@protoc_insertion_point(field_list:executor.TFPushRequest.tensors)
  return tensors_;
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace executor

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_tfoplibrary_2eproto__INCLUDED

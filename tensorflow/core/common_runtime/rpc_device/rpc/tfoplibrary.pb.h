// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tfoplibrary.proto

#ifndef PROTOBUF_tfoplibrary_2eproto__INCLUDED
#define PROTOBUF_tfoplibrary_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3002000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3002000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "tensorflow/core/framework/node_def.pb.h"
#include "tensorflow/core/framework/function.pb.h"
#include "tensorflow/core/framework/tensor.pb.h"
#include "tensorflow/core/protobuf/config.pb.h"
#include "tensorflow/core/lib/core/error_codes.pb.h"
// @@protoc_insertion_point(includes)
namespace executor {
class TFOpContextDef;
class TFOpContextDefDefaultTypeInternal;
extern TFOpContextDefDefaultTypeInternal _TFOpContextDef_default_instance_;
class TFOpContextUpdate;
class TFOpContextUpdateDefaultTypeInternal;
extern TFOpContextUpdateDefaultTypeInternal _TFOpContextUpdate_default_instance_;
class TFOpKernelDef;
class TFOpKernelDefDefaultTypeInternal;
extern TFOpKernelDefDefaultTypeInternal _TFOpKernelDef_default_instance_;
class TFRendezItem;
class TFRendezItemDefaultTypeInternal;
extern TFRendezItemDefaultTypeInternal _TFRendezItem_default_instance_;
class TFRendezRecvRequests;
class TFRendezRecvRequestsDefaultTypeInternal;
extern TFRendezRecvRequestsDefaultTypeInternal _TFRendezRecvRequests_default_instance_;
class TFRendezRecvResponse;
class TFRendezRecvResponseDefaultTypeInternal;
extern TFRendezRecvResponseDefaultTypeInternal _TFRendezRecvResponse_default_instance_;
class TFTensorItem;
class TFTensorItemDefaultTypeInternal;
extern TFTensorItemDefaultTypeInternal _TFTensorItem_default_instance_;
}  // namespace executor
namespace tensorflow {
class ConfigProto;
class ConfigProtoDefaultTypeInternal;
extern ConfigProtoDefaultTypeInternal _ConfigProto_default_instance_;
class FunctionDef;
class FunctionDefDefaultTypeInternal;
extern FunctionDefDefaultTypeInternal _FunctionDef_default_instance_;
class FunctionDefLibrary;
class FunctionDefLibraryDefaultTypeInternal;
extern FunctionDefLibraryDefaultTypeInternal _FunctionDefLibrary_default_instance_;
class GPUOptions;
class GPUOptionsDefaultTypeInternal;
extern GPUOptionsDefaultTypeInternal _GPUOptions_default_instance_;
class GradientDef;
class GradientDefDefaultTypeInternal;
extern GradientDefDefaultTypeInternal _GradientDef_default_instance_;
class GraphOptions;
class GraphOptionsDefaultTypeInternal;
extern GraphOptionsDefaultTypeInternal _GraphOptions_default_instance_;
class NodeDef;
class NodeDefDefaultTypeInternal;
extern NodeDefDefaultTypeInternal _NodeDef_default_instance_;
class OptimizerOptions;
class OptimizerOptionsDefaultTypeInternal;
extern OptimizerOptionsDefaultTypeInternal _OptimizerOptions_default_instance_;
class RPCOptions;
class RPCOptionsDefaultTypeInternal;
extern RPCOptionsDefaultTypeInternal _RPCOptions_default_instance_;
class RunMetadata;
class RunMetadataDefaultTypeInternal;
extern RunMetadataDefaultTypeInternal _RunMetadata_default_instance_;
class RunOptions;
class RunOptionsDefaultTypeInternal;
extern RunOptionsDefaultTypeInternal _RunOptions_default_instance_;
class TensorProto;
class TensorProtoDefaultTypeInternal;
extern TensorProtoDefaultTypeInternal _TensorProto_default_instance_;
class ThreadPoolOptionProto;
class ThreadPoolOptionProtoDefaultTypeInternal;
extern ThreadPoolOptionProtoDefaultTypeInternal _ThreadPoolOptionProto_default_instance_;
namespace error {
}  // namespace error
}  // namespace tensorflow

namespace executor {

namespace protobuf_tfoplibrary_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_tfoplibrary_2eproto

// ===================================================================

class TFOpKernelDef : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:executor.TFOpKernelDef) */ {
 public:
  TFOpKernelDef();
  virtual ~TFOpKernelDef();

  TFOpKernelDef(const TFOpKernelDef& from);

  inline TFOpKernelDef& operator=(const TFOpKernelDef& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TFOpKernelDef& default_instance();

  static inline const TFOpKernelDef* internal_default_instance() {
    return reinterpret_cast<const TFOpKernelDef*>(
               &_TFOpKernelDef_default_instance_);
  }

  void Swap(TFOpKernelDef* other);

  // implements Message ----------------------------------------------

  inline TFOpKernelDef* New() const PROTOBUF_FINAL { return New(NULL); }

  TFOpKernelDef* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TFOpKernelDef& from);
  void MergeFrom(const TFOpKernelDef& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TFOpKernelDef* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .tensorflow.NodeDef nodedef = 2;
  bool has_nodedef() const;
  void clear_nodedef();
  static const int kNodedefFieldNumber = 2;
  const ::tensorflow::NodeDef& nodedef() const;
  ::tensorflow::NodeDef* mutable_nodedef();
  ::tensorflow::NodeDef* release_nodedef();
  void set_allocated_nodedef(::tensorflow::NodeDef* nodedef);

  // .tensorflow.ConfigProto cfgProto = 3;
  bool has_cfgproto() const;
  void clear_cfgproto();
  static const int kCfgProtoFieldNumber = 3;
  const ::tensorflow::ConfigProto& cfgproto() const;
  ::tensorflow::ConfigProto* mutable_cfgproto();
  ::tensorflow::ConfigProto* release_cfgproto();
  void set_allocated_cfgproto(::tensorflow::ConfigProto* cfgproto);

  // .tensorflow.FunctionDefLibrary funcDef = 4;
  bool has_funcdef() const;
  void clear_funcdef();
  static const int kFuncDefFieldNumber = 4;
  const ::tensorflow::FunctionDefLibrary& funcdef() const;
  ::tensorflow::FunctionDefLibrary* mutable_funcdef();
  ::tensorflow::FunctionDefLibrary* release_funcdef();
  void set_allocated_funcdef(::tensorflow::FunctionDefLibrary* funcdef);

  // int32 graph_def_version = 1;
  void clear_graph_def_version();
  static const int kGraphDefVersionFieldNumber = 1;
  ::google::protobuf::int32 graph_def_version() const;
  void set_graph_def_version(::google::protobuf::int32 value);

  // bool isAsync = 5;
  void clear_isasync();
  static const int kIsAsyncFieldNumber = 5;
  bool isasync() const;
  void set_isasync(bool value);

  // @@protoc_insertion_point(class_scope:executor.TFOpKernelDef)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::tensorflow::NodeDef* nodedef_;
  ::tensorflow::ConfigProto* cfgproto_;
  ::tensorflow::FunctionDefLibrary* funcdef_;
  ::google::protobuf::int32 graph_def_version_;
  bool isasync_;
  mutable int _cached_size_;
  friend struct  protobuf_tfoplibrary_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TFOpContextDef : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:executor.TFOpContextDef) */ {
 public:
  TFOpContextDef();
  virtual ~TFOpContextDef();

  TFOpContextDef(const TFOpContextDef& from);

  inline TFOpContextDef& operator=(const TFOpContextDef& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TFOpContextDef& default_instance();

  static inline const TFOpContextDef* internal_default_instance() {
    return reinterpret_cast<const TFOpContextDef*>(
               &_TFOpContextDef_default_instance_);
  }

  void Swap(TFOpContextDef* other);

  // implements Message ----------------------------------------------

  inline TFOpContextDef* New() const PROTOBUF_FINAL { return New(NULL); }

  TFOpContextDef* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TFOpContextDef& from);
  void MergeFrom(const TFOpContextDef& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TFOpContextDef* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .executor.TFTensorItem inputs = 5;
  int inputs_size() const;
  void clear_inputs();
  static const int kInputsFieldNumber = 5;
  const ::executor::TFTensorItem& inputs(int index) const;
  ::executor::TFTensorItem* mutable_inputs(int index);
  ::executor::TFTensorItem* add_inputs();
  ::google::protobuf::RepeatedPtrField< ::executor::TFTensorItem >*
      mutable_inputs();
  const ::google::protobuf::RepeatedPtrField< ::executor::TFTensorItem >&
      inputs() const;

  // int64 step_id = 1;
  void clear_step_id();
  static const int kStepIdFieldNumber = 1;
  ::google::protobuf::int64 step_id() const;
  void set_step_id(::google::protobuf::int64 value);

  // uint64 frame_id = 2;
  void clear_frame_id();
  static const int kFrameIdFieldNumber = 2;
  ::google::protobuf::uint64 frame_id() const;
  void set_frame_id(::google::protobuf::uint64 value);

  // int64 iter_id = 3;
  void clear_iter_id();
  static const int kIterIdFieldNumber = 3;
  ::google::protobuf::int64 iter_id() const;
  void set_iter_id(::google::protobuf::int64 value);

  // bool is_input_dead = 4;
  void clear_is_input_dead();
  static const int kIsInputDeadFieldNumber = 4;
  bool is_input_dead() const;
  void set_is_input_dead(bool value);

  // @@protoc_insertion_point(class_scope:executor.TFOpContextDef)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::executor::TFTensorItem > inputs_;
  ::google::protobuf::int64 step_id_;
  ::google::protobuf::uint64 frame_id_;
  ::google::protobuf::int64 iter_id_;
  bool is_input_dead_;
  mutable int _cached_size_;
  friend struct  protobuf_tfoplibrary_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TFOpContextUpdate : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:executor.TFOpContextUpdate) */ {
 public:
  TFOpContextUpdate();
  virtual ~TFOpContextUpdate();

  TFOpContextUpdate(const TFOpContextUpdate& from);

  inline TFOpContextUpdate& operator=(const TFOpContextUpdate& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TFOpContextUpdate& default_instance();

  static inline const TFOpContextUpdate* internal_default_instance() {
    return reinterpret_cast<const TFOpContextUpdate*>(
               &_TFOpContextUpdate_default_instance_);
  }

  void Swap(TFOpContextUpdate* other);

  // implements Message ----------------------------------------------

  inline TFOpContextUpdate* New() const PROTOBUF_FINAL { return New(NULL); }

  TFOpContextUpdate* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TFOpContextUpdate& from);
  void MergeFrom(const TFOpContextUpdate& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TFOpContextUpdate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .executor.TFTensorItem outputs = 2;
  int outputs_size() const;
  void clear_outputs();
  static const int kOutputsFieldNumber = 2;
  const ::executor::TFTensorItem& outputs(int index) const;
  ::executor::TFTensorItem* mutable_outputs(int index);
  ::executor::TFTensorItem* add_outputs();
  ::google::protobuf::RepeatedPtrField< ::executor::TFTensorItem >*
      mutable_outputs();
  const ::google::protobuf::RepeatedPtrField< ::executor::TFTensorItem >&
      outputs() const;

  // repeated .executor.TFRendezItem rendezTensors = 3;
  int rendeztensors_size() const;
  void clear_rendeztensors();
  static const int kRendezTensorsFieldNumber = 3;
  const ::executor::TFRendezItem& rendeztensors(int index) const;
  ::executor::TFRendezItem* mutable_rendeztensors(int index);
  ::executor::TFRendezItem* add_rendeztensors();
  ::google::protobuf::RepeatedPtrField< ::executor::TFRendezItem >*
      mutable_rendeztensors();
  const ::google::protobuf::RepeatedPtrField< ::executor::TFRendezItem >&
      rendeztensors() const;

  // string status_msg = 5;
  void clear_status_msg();
  static const int kStatusMsgFieldNumber = 5;
  const ::std::string& status_msg() const;
  void set_status_msg(const ::std::string& value);
  #if LANG_CXX11
  void set_status_msg(::std::string&& value);
  #endif
  void set_status_msg(const char* value);
  void set_status_msg(const char* value, size_t size);
  ::std::string* mutable_status_msg();
  ::std::string* release_status_msg();
  void set_allocated_status_msg(::std::string* status_msg);

  // bool is_output_dead = 1;
  void clear_is_output_dead();
  static const int kIsOutputDeadFieldNumber = 1;
  bool is_output_dead() const;
  void set_is_output_dead(bool value);

  // .tensorflow.error.Code status_code = 4;
  void clear_status_code();
  static const int kStatusCodeFieldNumber = 4;
  ::tensorflow::error::Code status_code() const;
  void set_status_code(::tensorflow::error::Code value);

  // @@protoc_insertion_point(class_scope:executor.TFOpContextUpdate)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::executor::TFTensorItem > outputs_;
  ::google::protobuf::RepeatedPtrField< ::executor::TFRendezItem > rendeztensors_;
  ::google::protobuf::internal::ArenaStringPtr status_msg_;
  bool is_output_dead_;
  int status_code_;
  mutable int _cached_size_;
  friend struct  protobuf_tfoplibrary_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TFRendezItem : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:executor.TFRendezItem) */ {
 public:
  TFRendezItem();
  virtual ~TFRendezItem();

  TFRendezItem(const TFRendezItem& from);

  inline TFRendezItem& operator=(const TFRendezItem& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TFRendezItem& default_instance();

  static inline const TFRendezItem* internal_default_instance() {
    return reinterpret_cast<const TFRendezItem*>(
               &_TFRendezItem_default_instance_);
  }

  void Swap(TFRendezItem* other);

  // implements Message ----------------------------------------------

  inline TFRendezItem* New() const PROTOBUF_FINAL { return New(NULL); }

  TFRendezItem* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TFRendezItem& from);
  void MergeFrom(const TFRendezItem& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TFRendezItem* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // .tensorflow.TensorProto val = 4;
  bool has_val() const;
  void clear_val();
  static const int kValFieldNumber = 4;
  const ::tensorflow::TensorProto& val() const;
  ::tensorflow::TensorProto* mutable_val();
  ::tensorflow::TensorProto* release_val();
  void set_allocated_val(::tensorflow::TensorProto* val);

  // uint32 allocAttributes = 2;
  void clear_allocattributes();
  static const int kAllocAttributesFieldNumber = 2;
  ::google::protobuf::uint32 allocattributes() const;
  void set_allocattributes(::google::protobuf::uint32 value);

  // bool isDead = 3;
  void clear_isdead();
  static const int kIsDeadFieldNumber = 3;
  bool isdead() const;
  void set_isdead(bool value);

  // @@protoc_insertion_point(class_scope:executor.TFRendezItem)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::tensorflow::TensorProto* val_;
  ::google::protobuf::uint32 allocattributes_;
  bool isdead_;
  mutable int _cached_size_;
  friend struct  protobuf_tfoplibrary_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TFRendezRecvRequests : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:executor.TFRendezRecvRequests) */ {
 public:
  TFRendezRecvRequests();
  virtual ~TFRendezRecvRequests();

  TFRendezRecvRequests(const TFRendezRecvRequests& from);

  inline TFRendezRecvRequests& operator=(const TFRendezRecvRequests& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TFRendezRecvRequests& default_instance();

  static inline const TFRendezRecvRequests* internal_default_instance() {
    return reinterpret_cast<const TFRendezRecvRequests*>(
               &_TFRendezRecvRequests_default_instance_);
  }

  void Swap(TFRendezRecvRequests* other);

  // implements Message ----------------------------------------------

  inline TFRendezRecvRequests* New() const PROTOBUF_FINAL { return New(NULL); }

  TFRendezRecvRequests* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TFRendezRecvRequests& from);
  void MergeFrom(const TFRendezRecvRequests& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TFRendezRecvRequests* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string key = 1;
  int key_size() const;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key(int index) const;
  ::std::string* mutable_key(int index);
  void set_key(int index, const ::std::string& value);
  void set_key(int index, const char* value);
  void set_key(int index, const char* value, size_t size);
  ::std::string* add_key();
  void add_key(const ::std::string& value);
  void add_key(const char* value);
  void add_key(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& key() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_key();

  // repeated uint32 allocAttributes = 2;
  int allocattributes_size() const;
  void clear_allocattributes();
  static const int kAllocAttributesFieldNumber = 2;
  ::google::protobuf::uint32 allocattributes(int index) const;
  void set_allocattributes(int index, ::google::protobuf::uint32 value);
  void add_allocattributes(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      allocattributes() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_allocattributes();

  // @@protoc_insertion_point(class_scope:executor.TFRendezRecvRequests)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> key_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > allocattributes_;
  mutable int _allocattributes_cached_byte_size_;
  mutable int _cached_size_;
  friend struct  protobuf_tfoplibrary_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TFRendezRecvResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:executor.TFRendezRecvResponse) */ {
 public:
  TFRendezRecvResponse();
  virtual ~TFRendezRecvResponse();

  TFRendezRecvResponse(const TFRendezRecvResponse& from);

  inline TFRendezRecvResponse& operator=(const TFRendezRecvResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TFRendezRecvResponse& default_instance();

  static inline const TFRendezRecvResponse* internal_default_instance() {
    return reinterpret_cast<const TFRendezRecvResponse*>(
               &_TFRendezRecvResponse_default_instance_);
  }

  void Swap(TFRendezRecvResponse* other);

  // implements Message ----------------------------------------------

  inline TFRendezRecvResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  TFRendezRecvResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TFRendezRecvResponse& from);
  void MergeFrom(const TFRendezRecvResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TFRendezRecvResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .executor.TFRendezItem items = 2;
  int items_size() const;
  void clear_items();
  static const int kItemsFieldNumber = 2;
  const ::executor::TFRendezItem& items(int index) const;
  ::executor::TFRendezItem* mutable_items(int index);
  ::executor::TFRendezItem* add_items();
  ::google::protobuf::RepeatedPtrField< ::executor::TFRendezItem >*
      mutable_items();
  const ::google::protobuf::RepeatedPtrField< ::executor::TFRendezItem >&
      items() const;

  // uint64 forSeq = 1;
  void clear_forseq();
  static const int kForSeqFieldNumber = 1;
  ::google::protobuf::uint64 forseq() const;
  void set_forseq(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:executor.TFRendezRecvResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::executor::TFRendezItem > items_;
  ::google::protobuf::uint64 forseq_;
  mutable int _cached_size_;
  friend struct  protobuf_tfoplibrary_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TFTensorItem : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:executor.TFTensorItem) */ {
 public:
  TFTensorItem();
  virtual ~TFTensorItem();

  TFTensorItem(const TFTensorItem& from);

  inline TFTensorItem& operator=(const TFTensorItem& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TFTensorItem& default_instance();

  static inline const TFTensorItem* internal_default_instance() {
    return reinterpret_cast<const TFTensorItem*>(
               &_TFTensorItem_default_instance_);
  }

  void Swap(TFTensorItem* other);

  // implements Message ----------------------------------------------

  inline TFTensorItem* New() const PROTOBUF_FINAL { return New(NULL); }

  TFTensorItem* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TFTensorItem& from);
  void MergeFrom(const TFTensorItem& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TFTensorItem* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 2;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // .tensorflow.TensorProto meta = 3;
  bool has_meta() const;
  void clear_meta();
  static const int kMetaFieldNumber = 3;
  const ::tensorflow::TensorProto& meta() const;
  ::tensorflow::TensorProto* mutable_meta();
  ::tensorflow::TensorProto* release_meta();
  void set_allocated_meta(::tensorflow::TensorProto* meta);

  // bool is_ref = 1;
  void clear_is_ref();
  static const int kIsRefFieldNumber = 1;
  bool is_ref() const;
  void set_is_ref(bool value);

  // @@protoc_insertion_point(class_scope:executor.TFTensorItem)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::tensorflow::TensorProto* meta_;
  bool is_ref_;
  mutable int _cached_size_;
  friend struct  protobuf_tfoplibrary_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// TFOpKernelDef

// int32 graph_def_version = 1;
inline void TFOpKernelDef::clear_graph_def_version() {
  graph_def_version_ = 0;
}
inline ::google::protobuf::int32 TFOpKernelDef::graph_def_version() const {
  // @@protoc_insertion_point(field_get:executor.TFOpKernelDef.graph_def_version)
  return graph_def_version_;
}
inline void TFOpKernelDef::set_graph_def_version(::google::protobuf::int32 value) {
  
  graph_def_version_ = value;
  // @@protoc_insertion_point(field_set:executor.TFOpKernelDef.graph_def_version)
}

// .tensorflow.NodeDef nodedef = 2;
inline bool TFOpKernelDef::has_nodedef() const {
  return this != internal_default_instance() && nodedef_ != NULL;
}
inline void TFOpKernelDef::clear_nodedef() {
  if (GetArenaNoVirtual() == NULL && nodedef_ != NULL) delete nodedef_;
  nodedef_ = NULL;
}
inline const ::tensorflow::NodeDef& TFOpKernelDef::nodedef() const {
  // @@protoc_insertion_point(field_get:executor.TFOpKernelDef.nodedef)
  return nodedef_ != NULL ? *nodedef_
                         : *::tensorflow::NodeDef::internal_default_instance();
}
inline ::tensorflow::NodeDef* TFOpKernelDef::mutable_nodedef() {
  
  if (nodedef_ == NULL) {
    nodedef_ = new ::tensorflow::NodeDef;
  }
  // @@protoc_insertion_point(field_mutable:executor.TFOpKernelDef.nodedef)
  return nodedef_;
}
inline ::tensorflow::NodeDef* TFOpKernelDef::release_nodedef() {
  // @@protoc_insertion_point(field_release:executor.TFOpKernelDef.nodedef)
  
  ::tensorflow::NodeDef* temp = nodedef_;
  nodedef_ = NULL;
  return temp;
}
inline void TFOpKernelDef::set_allocated_nodedef(::tensorflow::NodeDef* nodedef) {
  delete nodedef_;
  if (nodedef != NULL && nodedef->GetArena() != NULL) {
    ::tensorflow::NodeDef* new_nodedef = new ::tensorflow::NodeDef;
    new_nodedef->CopyFrom(*nodedef);
    nodedef = new_nodedef;
  }
  nodedef_ = nodedef;
  if (nodedef) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:executor.TFOpKernelDef.nodedef)
}

// .tensorflow.ConfigProto cfgProto = 3;
inline bool TFOpKernelDef::has_cfgproto() const {
  return this != internal_default_instance() && cfgproto_ != NULL;
}
inline void TFOpKernelDef::clear_cfgproto() {
  if (GetArenaNoVirtual() == NULL && cfgproto_ != NULL) delete cfgproto_;
  cfgproto_ = NULL;
}
inline const ::tensorflow::ConfigProto& TFOpKernelDef::cfgproto() const {
  // @@protoc_insertion_point(field_get:executor.TFOpKernelDef.cfgProto)
  return cfgproto_ != NULL ? *cfgproto_
                         : *::tensorflow::ConfigProto::internal_default_instance();
}
inline ::tensorflow::ConfigProto* TFOpKernelDef::mutable_cfgproto() {
  
  if (cfgproto_ == NULL) {
    cfgproto_ = new ::tensorflow::ConfigProto;
  }
  // @@protoc_insertion_point(field_mutable:executor.TFOpKernelDef.cfgProto)
  return cfgproto_;
}
inline ::tensorflow::ConfigProto* TFOpKernelDef::release_cfgproto() {
  // @@protoc_insertion_point(field_release:executor.TFOpKernelDef.cfgProto)
  
  ::tensorflow::ConfigProto* temp = cfgproto_;
  cfgproto_ = NULL;
  return temp;
}
inline void TFOpKernelDef::set_allocated_cfgproto(::tensorflow::ConfigProto* cfgproto) {
  delete cfgproto_;
  if (cfgproto != NULL && cfgproto->GetArena() != NULL) {
    ::tensorflow::ConfigProto* new_cfgproto = new ::tensorflow::ConfigProto;
    new_cfgproto->CopyFrom(*cfgproto);
    cfgproto = new_cfgproto;
  }
  cfgproto_ = cfgproto;
  if (cfgproto) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:executor.TFOpKernelDef.cfgProto)
}

// .tensorflow.FunctionDefLibrary funcDef = 4;
inline bool TFOpKernelDef::has_funcdef() const {
  return this != internal_default_instance() && funcdef_ != NULL;
}
inline void TFOpKernelDef::clear_funcdef() {
  if (GetArenaNoVirtual() == NULL && funcdef_ != NULL) delete funcdef_;
  funcdef_ = NULL;
}
inline const ::tensorflow::FunctionDefLibrary& TFOpKernelDef::funcdef() const {
  // @@protoc_insertion_point(field_get:executor.TFOpKernelDef.funcDef)
  return funcdef_ != NULL ? *funcdef_
                         : *::tensorflow::FunctionDefLibrary::internal_default_instance();
}
inline ::tensorflow::FunctionDefLibrary* TFOpKernelDef::mutable_funcdef() {
  
  if (funcdef_ == NULL) {
    funcdef_ = new ::tensorflow::FunctionDefLibrary;
  }
  // @@protoc_insertion_point(field_mutable:executor.TFOpKernelDef.funcDef)
  return funcdef_;
}
inline ::tensorflow::FunctionDefLibrary* TFOpKernelDef::release_funcdef() {
  // @@protoc_insertion_point(field_release:executor.TFOpKernelDef.funcDef)
  
  ::tensorflow::FunctionDefLibrary* temp = funcdef_;
  funcdef_ = NULL;
  return temp;
}
inline void TFOpKernelDef::set_allocated_funcdef(::tensorflow::FunctionDefLibrary* funcdef) {
  delete funcdef_;
  if (funcdef != NULL && funcdef->GetArena() != NULL) {
    ::tensorflow::FunctionDefLibrary* new_funcdef = new ::tensorflow::FunctionDefLibrary;
    new_funcdef->CopyFrom(*funcdef);
    funcdef = new_funcdef;
  }
  funcdef_ = funcdef;
  if (funcdef) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:executor.TFOpKernelDef.funcDef)
}

// bool isAsync = 5;
inline void TFOpKernelDef::clear_isasync() {
  isasync_ = false;
}
inline bool TFOpKernelDef::isasync() const {
  // @@protoc_insertion_point(field_get:executor.TFOpKernelDef.isAsync)
  return isasync_;
}
inline void TFOpKernelDef::set_isasync(bool value) {
  
  isasync_ = value;
  // @@protoc_insertion_point(field_set:executor.TFOpKernelDef.isAsync)
}

// -------------------------------------------------------------------

// TFOpContextDef

// int64 step_id = 1;
inline void TFOpContextDef::clear_step_id() {
  step_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 TFOpContextDef::step_id() const {
  // @@protoc_insertion_point(field_get:executor.TFOpContextDef.step_id)
  return step_id_;
}
inline void TFOpContextDef::set_step_id(::google::protobuf::int64 value) {
  
  step_id_ = value;
  // @@protoc_insertion_point(field_set:executor.TFOpContextDef.step_id)
}

// uint64 frame_id = 2;
inline void TFOpContextDef::clear_frame_id() {
  frame_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 TFOpContextDef::frame_id() const {
  // @@protoc_insertion_point(field_get:executor.TFOpContextDef.frame_id)
  return frame_id_;
}
inline void TFOpContextDef::set_frame_id(::google::protobuf::uint64 value) {
  
  frame_id_ = value;
  // @@protoc_insertion_point(field_set:executor.TFOpContextDef.frame_id)
}

// int64 iter_id = 3;
inline void TFOpContextDef::clear_iter_id() {
  iter_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 TFOpContextDef::iter_id() const {
  // @@protoc_insertion_point(field_get:executor.TFOpContextDef.iter_id)
  return iter_id_;
}
inline void TFOpContextDef::set_iter_id(::google::protobuf::int64 value) {
  
  iter_id_ = value;
  // @@protoc_insertion_point(field_set:executor.TFOpContextDef.iter_id)
}

// bool is_input_dead = 4;
inline void TFOpContextDef::clear_is_input_dead() {
  is_input_dead_ = false;
}
inline bool TFOpContextDef::is_input_dead() const {
  // @@protoc_insertion_point(field_get:executor.TFOpContextDef.is_input_dead)
  return is_input_dead_;
}
inline void TFOpContextDef::set_is_input_dead(bool value) {
  
  is_input_dead_ = value;
  // @@protoc_insertion_point(field_set:executor.TFOpContextDef.is_input_dead)
}

// repeated .executor.TFTensorItem inputs = 5;
inline int TFOpContextDef::inputs_size() const {
  return inputs_.size();
}
inline void TFOpContextDef::clear_inputs() {
  inputs_.Clear();
}
inline const ::executor::TFTensorItem& TFOpContextDef::inputs(int index) const {
  // @@protoc_insertion_point(field_get:executor.TFOpContextDef.inputs)
  return inputs_.Get(index);
}
inline ::executor::TFTensorItem* TFOpContextDef::mutable_inputs(int index) {
  // @@protoc_insertion_point(field_mutable:executor.TFOpContextDef.inputs)
  return inputs_.Mutable(index);
}
inline ::executor::TFTensorItem* TFOpContextDef::add_inputs() {
  // @@protoc_insertion_point(field_add:executor.TFOpContextDef.inputs)
  return inputs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::executor::TFTensorItem >*
TFOpContextDef::mutable_inputs() {
  // @@protoc_insertion_point(field_mutable_list:executor.TFOpContextDef.inputs)
  return &inputs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::executor::TFTensorItem >&
TFOpContextDef::inputs() const {
  // @@protoc_insertion_point(field_list:executor.TFOpContextDef.inputs)
  return inputs_;
}

// -------------------------------------------------------------------

// TFOpContextUpdate

// bool is_output_dead = 1;
inline void TFOpContextUpdate::clear_is_output_dead() {
  is_output_dead_ = false;
}
inline bool TFOpContextUpdate::is_output_dead() const {
  // @@protoc_insertion_point(field_get:executor.TFOpContextUpdate.is_output_dead)
  return is_output_dead_;
}
inline void TFOpContextUpdate::set_is_output_dead(bool value) {
  
  is_output_dead_ = value;
  // @@protoc_insertion_point(field_set:executor.TFOpContextUpdate.is_output_dead)
}

// repeated .executor.TFTensorItem outputs = 2;
inline int TFOpContextUpdate::outputs_size() const {
  return outputs_.size();
}
inline void TFOpContextUpdate::clear_outputs() {
  outputs_.Clear();
}
inline const ::executor::TFTensorItem& TFOpContextUpdate::outputs(int index) const {
  // @@protoc_insertion_point(field_get:executor.TFOpContextUpdate.outputs)
  return outputs_.Get(index);
}
inline ::executor::TFTensorItem* TFOpContextUpdate::mutable_outputs(int index) {
  // @@protoc_insertion_point(field_mutable:executor.TFOpContextUpdate.outputs)
  return outputs_.Mutable(index);
}
inline ::executor::TFTensorItem* TFOpContextUpdate::add_outputs() {
  // @@protoc_insertion_point(field_add:executor.TFOpContextUpdate.outputs)
  return outputs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::executor::TFTensorItem >*
TFOpContextUpdate::mutable_outputs() {
  // @@protoc_insertion_point(field_mutable_list:executor.TFOpContextUpdate.outputs)
  return &outputs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::executor::TFTensorItem >&
TFOpContextUpdate::outputs() const {
  // @@protoc_insertion_point(field_list:executor.TFOpContextUpdate.outputs)
  return outputs_;
}

// repeated .executor.TFRendezItem rendezTensors = 3;
inline int TFOpContextUpdate::rendeztensors_size() const {
  return rendeztensors_.size();
}
inline void TFOpContextUpdate::clear_rendeztensors() {
  rendeztensors_.Clear();
}
inline const ::executor::TFRendezItem& TFOpContextUpdate::rendeztensors(int index) const {
  // @@protoc_insertion_point(field_get:executor.TFOpContextUpdate.rendezTensors)
  return rendeztensors_.Get(index);
}
inline ::executor::TFRendezItem* TFOpContextUpdate::mutable_rendeztensors(int index) {
  // @@protoc_insertion_point(field_mutable:executor.TFOpContextUpdate.rendezTensors)
  return rendeztensors_.Mutable(index);
}
inline ::executor::TFRendezItem* TFOpContextUpdate::add_rendeztensors() {
  // @@protoc_insertion_point(field_add:executor.TFOpContextUpdate.rendezTensors)
  return rendeztensors_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::executor::TFRendezItem >*
TFOpContextUpdate::mutable_rendeztensors() {
  // @@protoc_insertion_point(field_mutable_list:executor.TFOpContextUpdate.rendezTensors)
  return &rendeztensors_;
}
inline const ::google::protobuf::RepeatedPtrField< ::executor::TFRendezItem >&
TFOpContextUpdate::rendeztensors() const {
  // @@protoc_insertion_point(field_list:executor.TFOpContextUpdate.rendezTensors)
  return rendeztensors_;
}

// .tensorflow.error.Code status_code = 4;
inline void TFOpContextUpdate::clear_status_code() {
  status_code_ = 0;
}
inline ::tensorflow::error::Code TFOpContextUpdate::status_code() const {
  // @@protoc_insertion_point(field_get:executor.TFOpContextUpdate.status_code)
  return static_cast< ::tensorflow::error::Code >(status_code_);
}
inline void TFOpContextUpdate::set_status_code(::tensorflow::error::Code value) {
  
  status_code_ = value;
  // @@protoc_insertion_point(field_set:executor.TFOpContextUpdate.status_code)
}

// string status_msg = 5;
inline void TFOpContextUpdate::clear_status_msg() {
  status_msg_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TFOpContextUpdate::status_msg() const {
  // @@protoc_insertion_point(field_get:executor.TFOpContextUpdate.status_msg)
  return status_msg_.GetNoArena();
}
inline void TFOpContextUpdate::set_status_msg(const ::std::string& value) {
  
  status_msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:executor.TFOpContextUpdate.status_msg)
}
#if LANG_CXX11
inline void TFOpContextUpdate::set_status_msg(::std::string&& value) {
  
  status_msg_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:executor.TFOpContextUpdate.status_msg)
}
#endif
inline void TFOpContextUpdate::set_status_msg(const char* value) {
  
  status_msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:executor.TFOpContextUpdate.status_msg)
}
inline void TFOpContextUpdate::set_status_msg(const char* value, size_t size) {
  
  status_msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:executor.TFOpContextUpdate.status_msg)
}
inline ::std::string* TFOpContextUpdate::mutable_status_msg() {
  
  // @@protoc_insertion_point(field_mutable:executor.TFOpContextUpdate.status_msg)
  return status_msg_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TFOpContextUpdate::release_status_msg() {
  // @@protoc_insertion_point(field_release:executor.TFOpContextUpdate.status_msg)
  
  return status_msg_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TFOpContextUpdate::set_allocated_status_msg(::std::string* status_msg) {
  if (status_msg != NULL) {
    
  } else {
    
  }
  status_msg_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), status_msg);
  // @@protoc_insertion_point(field_set_allocated:executor.TFOpContextUpdate.status_msg)
}

// -------------------------------------------------------------------

// TFRendezItem

// string key = 1;
inline void TFRendezItem::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TFRendezItem::key() const {
  // @@protoc_insertion_point(field_get:executor.TFRendezItem.key)
  return key_.GetNoArena();
}
inline void TFRendezItem::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:executor.TFRendezItem.key)
}
#if LANG_CXX11
inline void TFRendezItem::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:executor.TFRendezItem.key)
}
#endif
inline void TFRendezItem::set_key(const char* value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:executor.TFRendezItem.key)
}
inline void TFRendezItem::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:executor.TFRendezItem.key)
}
inline ::std::string* TFRendezItem::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:executor.TFRendezItem.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TFRendezItem::release_key() {
  // @@protoc_insertion_point(field_release:executor.TFRendezItem.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TFRendezItem::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:executor.TFRendezItem.key)
}

// uint32 allocAttributes = 2;
inline void TFRendezItem::clear_allocattributes() {
  allocattributes_ = 0u;
}
inline ::google::protobuf::uint32 TFRendezItem::allocattributes() const {
  // @@protoc_insertion_point(field_get:executor.TFRendezItem.allocAttributes)
  return allocattributes_;
}
inline void TFRendezItem::set_allocattributes(::google::protobuf::uint32 value) {
  
  allocattributes_ = value;
  // @@protoc_insertion_point(field_set:executor.TFRendezItem.allocAttributes)
}

// bool isDead = 3;
inline void TFRendezItem::clear_isdead() {
  isdead_ = false;
}
inline bool TFRendezItem::isdead() const {
  // @@protoc_insertion_point(field_get:executor.TFRendezItem.isDead)
  return isdead_;
}
inline void TFRendezItem::set_isdead(bool value) {
  
  isdead_ = value;
  // @@protoc_insertion_point(field_set:executor.TFRendezItem.isDead)
}

// .tensorflow.TensorProto val = 4;
inline bool TFRendezItem::has_val() const {
  return this != internal_default_instance() && val_ != NULL;
}
inline void TFRendezItem::clear_val() {
  if (GetArenaNoVirtual() == NULL && val_ != NULL) delete val_;
  val_ = NULL;
}
inline const ::tensorflow::TensorProto& TFRendezItem::val() const {
  // @@protoc_insertion_point(field_get:executor.TFRendezItem.val)
  return val_ != NULL ? *val_
                         : *::tensorflow::TensorProto::internal_default_instance();
}
inline ::tensorflow::TensorProto* TFRendezItem::mutable_val() {
  
  if (val_ == NULL) {
    val_ = new ::tensorflow::TensorProto;
  }
  // @@protoc_insertion_point(field_mutable:executor.TFRendezItem.val)
  return val_;
}
inline ::tensorflow::TensorProto* TFRendezItem::release_val() {
  // @@protoc_insertion_point(field_release:executor.TFRendezItem.val)
  
  ::tensorflow::TensorProto* temp = val_;
  val_ = NULL;
  return temp;
}
inline void TFRendezItem::set_allocated_val(::tensorflow::TensorProto* val) {
  delete val_;
  if (val != NULL && val->GetArena() != NULL) {
    ::tensorflow::TensorProto* new_val = new ::tensorflow::TensorProto;
    new_val->CopyFrom(*val);
    val = new_val;
  }
  val_ = val;
  if (val) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:executor.TFRendezItem.val)
}

// -------------------------------------------------------------------

// TFRendezRecvRequests

// repeated string key = 1;
inline int TFRendezRecvRequests::key_size() const {
  return key_.size();
}
inline void TFRendezRecvRequests::clear_key() {
  key_.Clear();
}
inline const ::std::string& TFRendezRecvRequests::key(int index) const {
  // @@protoc_insertion_point(field_get:executor.TFRendezRecvRequests.key)
  return key_.Get(index);
}
inline ::std::string* TFRendezRecvRequests::mutable_key(int index) {
  // @@protoc_insertion_point(field_mutable:executor.TFRendezRecvRequests.key)
  return key_.Mutable(index);
}
inline void TFRendezRecvRequests::set_key(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:executor.TFRendezRecvRequests.key)
  key_.Mutable(index)->assign(value);
}
inline void TFRendezRecvRequests::set_key(int index, const char* value) {
  key_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:executor.TFRendezRecvRequests.key)
}
inline void TFRendezRecvRequests::set_key(int index, const char* value, size_t size) {
  key_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:executor.TFRendezRecvRequests.key)
}
inline ::std::string* TFRendezRecvRequests::add_key() {
  // @@protoc_insertion_point(field_add_mutable:executor.TFRendezRecvRequests.key)
  return key_.Add();
}
inline void TFRendezRecvRequests::add_key(const ::std::string& value) {
  key_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:executor.TFRendezRecvRequests.key)
}
inline void TFRendezRecvRequests::add_key(const char* value) {
  key_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:executor.TFRendezRecvRequests.key)
}
inline void TFRendezRecvRequests::add_key(const char* value, size_t size) {
  key_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:executor.TFRendezRecvRequests.key)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
TFRendezRecvRequests::key() const {
  // @@protoc_insertion_point(field_list:executor.TFRendezRecvRequests.key)
  return key_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
TFRendezRecvRequests::mutable_key() {
  // @@protoc_insertion_point(field_mutable_list:executor.TFRendezRecvRequests.key)
  return &key_;
}

// repeated uint32 allocAttributes = 2;
inline int TFRendezRecvRequests::allocattributes_size() const {
  return allocattributes_.size();
}
inline void TFRendezRecvRequests::clear_allocattributes() {
  allocattributes_.Clear();
}
inline ::google::protobuf::uint32 TFRendezRecvRequests::allocattributes(int index) const {
  // @@protoc_insertion_point(field_get:executor.TFRendezRecvRequests.allocAttributes)
  return allocattributes_.Get(index);
}
inline void TFRendezRecvRequests::set_allocattributes(int index, ::google::protobuf::uint32 value) {
  allocattributes_.Set(index, value);
  // @@protoc_insertion_point(field_set:executor.TFRendezRecvRequests.allocAttributes)
}
inline void TFRendezRecvRequests::add_allocattributes(::google::protobuf::uint32 value) {
  allocattributes_.Add(value);
  // @@protoc_insertion_point(field_add:executor.TFRendezRecvRequests.allocAttributes)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
TFRendezRecvRequests::allocattributes() const {
  // @@protoc_insertion_point(field_list:executor.TFRendezRecvRequests.allocAttributes)
  return allocattributes_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
TFRendezRecvRequests::mutable_allocattributes() {
  // @@protoc_insertion_point(field_mutable_list:executor.TFRendezRecvRequests.allocAttributes)
  return &allocattributes_;
}

// -------------------------------------------------------------------

// TFRendezRecvResponse

// uint64 forSeq = 1;
inline void TFRendezRecvResponse::clear_forseq() {
  forseq_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 TFRendezRecvResponse::forseq() const {
  // @@protoc_insertion_point(field_get:executor.TFRendezRecvResponse.forSeq)
  return forseq_;
}
inline void TFRendezRecvResponse::set_forseq(::google::protobuf::uint64 value) {
  
  forseq_ = value;
  // @@protoc_insertion_point(field_set:executor.TFRendezRecvResponse.forSeq)
}

// repeated .executor.TFRendezItem items = 2;
inline int TFRendezRecvResponse::items_size() const {
  return items_.size();
}
inline void TFRendezRecvResponse::clear_items() {
  items_.Clear();
}
inline const ::executor::TFRendezItem& TFRendezRecvResponse::items(int index) const {
  // @@protoc_insertion_point(field_get:executor.TFRendezRecvResponse.items)
  return items_.Get(index);
}
inline ::executor::TFRendezItem* TFRendezRecvResponse::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:executor.TFRendezRecvResponse.items)
  return items_.Mutable(index);
}
inline ::executor::TFRendezItem* TFRendezRecvResponse::add_items() {
  // @@protoc_insertion_point(field_add:executor.TFRendezRecvResponse.items)
  return items_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::executor::TFRendezItem >*
TFRendezRecvResponse::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:executor.TFRendezRecvResponse.items)
  return &items_;
}
inline const ::google::protobuf::RepeatedPtrField< ::executor::TFRendezItem >&
TFRendezRecvResponse::items() const {
  // @@protoc_insertion_point(field_list:executor.TFRendezRecvResponse.items)
  return items_;
}

// -------------------------------------------------------------------

// TFTensorItem

// bool is_ref = 1;
inline void TFTensorItem::clear_is_ref() {
  is_ref_ = false;
}
inline bool TFTensorItem::is_ref() const {
  // @@protoc_insertion_point(field_get:executor.TFTensorItem.is_ref)
  return is_ref_;
}
inline void TFTensorItem::set_is_ref(bool value) {
  
  is_ref_ = value;
  // @@protoc_insertion_point(field_set:executor.TFTensorItem.is_ref)
}

// string name = 2;
inline void TFTensorItem::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TFTensorItem::name() const {
  // @@protoc_insertion_point(field_get:executor.TFTensorItem.name)
  return name_.GetNoArena();
}
inline void TFTensorItem::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:executor.TFTensorItem.name)
}
#if LANG_CXX11
inline void TFTensorItem::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:executor.TFTensorItem.name)
}
#endif
inline void TFTensorItem::set_name(const char* value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:executor.TFTensorItem.name)
}
inline void TFTensorItem::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:executor.TFTensorItem.name)
}
inline ::std::string* TFTensorItem::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:executor.TFTensorItem.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TFTensorItem::release_name() {
  // @@protoc_insertion_point(field_release:executor.TFTensorItem.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TFTensorItem::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:executor.TFTensorItem.name)
}

// .tensorflow.TensorProto meta = 3;
inline bool TFTensorItem::has_meta() const {
  return this != internal_default_instance() && meta_ != NULL;
}
inline void TFTensorItem::clear_meta() {
  if (GetArenaNoVirtual() == NULL && meta_ != NULL) delete meta_;
  meta_ = NULL;
}
inline const ::tensorflow::TensorProto& TFTensorItem::meta() const {
  // @@protoc_insertion_point(field_get:executor.TFTensorItem.meta)
  return meta_ != NULL ? *meta_
                         : *::tensorflow::TensorProto::internal_default_instance();
}
inline ::tensorflow::TensorProto* TFTensorItem::mutable_meta() {
  
  if (meta_ == NULL) {
    meta_ = new ::tensorflow::TensorProto;
  }
  // @@protoc_insertion_point(field_mutable:executor.TFTensorItem.meta)
  return meta_;
}
inline ::tensorflow::TensorProto* TFTensorItem::release_meta() {
  // @@protoc_insertion_point(field_release:executor.TFTensorItem.meta)
  
  ::tensorflow::TensorProto* temp = meta_;
  meta_ = NULL;
  return temp;
}
inline void TFTensorItem::set_allocated_meta(::tensorflow::TensorProto* meta) {
  delete meta_;
  if (meta != NULL && meta->GetArena() != NULL) {
    ::tensorflow::TensorProto* new_meta = new ::tensorflow::TensorProto;
    new_meta->CopyFrom(*meta);
    meta = new_meta;
  }
  meta_ = meta;
  if (meta) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:executor.TFTensorItem.meta)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace executor

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_tfoplibrary_2eproto__INCLUDED
